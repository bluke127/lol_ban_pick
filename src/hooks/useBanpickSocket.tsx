import { useEffect, useRef } from 'react';
import { useBanStore, usePopupStore, useRulesStore, useSocketStore, useUserStore } from '@/store';
import { usePathname, useSearchParams } from 'next/navigation';
import { useRouter } from 'next/navigation';
import { InfoData, usePeerlessStore } from '@/store/banpick';

function useBanpickSocket({ userId: _userId, roomId }: { userId: string; roomId: string }) {
  const { setIsOpen, setBtnList, setContent } = usePopupStore();
  useRulesStore();
  const {
    setCurrentSelectedPick,
    setBanPickObject,
    setChangeChampionInfo,
    setCurrentLocation,
    setSelectedTeamIndex,
    setClearBanPickObject,
    setClearSelectTeamIndex,
    setClearCurrentLocation,
  } = useBanStore();
  const { setTeamBan, setBlueBan, setRedBan, setRedBanClear, setBlueBanClear } = usePeerlessStore();

  //room id
  const { setRoomId, ws, setWs } = useSocketStore();
  //user id
  const { setUserId } = useUserStore();

  const searchParams = useSearchParams();
  const router = useRouter();
  const pathName = usePathname();
  const {
    role,
    setRules,
    setHostRules,
    setGuestRules,
    hostInfo,
    banpickMode,
    peopleMode,
    timeUnlimited,
    nowSet,
    position,
    audienceCount,
    setPeerlessSet,
  } = useRulesStore();
  const socketRef = useRef<WebSocket | null>(null);
  const lineMapping: Record<string, number> = {
    top: 0,
    jungle: 1,
    mid: 2,
    ad: 3,
    sup: 4,
  };

  useEffect(() => {
    if (pathName !== '/' && !roomId && !searchParams?.get('roomId')) {
      console.log(`üì© ÏÉà Î©îÏãúÏßÄ: noRoom`);
      setIsOpen(true);
      setContent('Í≥µÏú†Îêú Í≤åÏûÑÏù¥ ÏóÜÏäµÎãàÎã§.');
      setBtnList([
        {
          text: 'ÎèåÏïÑÍ∞ÄÍ∏∞',
          func: () => {
            setIsOpen(false);
            router.push('/');
          },
        },
      ]);
    } else if (pathName !== '/' && roomId && !searchParams?.get('roomId')) {
      ws?.send(
        JSON.stringify({
          type: 'join',
          userId: _userId,
          roomId: `${searchParams!.get('roomId') ? searchParams!.get('roomId') : roomId}`,
          banpickMode,
          peopleMode,
          timeUnlimited,
          nowSet,
          hostInfo,
          host: true,
          role: 'host',
          position: `${searchParams!.get('position') ? searchParams!.get('position') : position}`,
        }),
      );
    }
  }, [pathName]);

  const setSocket = () => {
    // WebSocketÏù¥ Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏúºÎ©¥ ÏÉàÎ°ú Ïó∞Í≤∞ ÏãúÎèÑ
    if (socketRef.current) return;
    if (ws && !searchParams?.get(roomId)) return;
    if (!socketRef.current && !ws) {
      console.log(_userId, 'userid');
      const userId = _userId;
      setUserId(_userId);
      //host Îäî postion ÏùÑ ÎçòÏ†∏Ï£ºÏßÄ ÏïäÏùå
      const positionValue = (searchParams!.get('position') as 'blue' | 'red' | 'audience') ?? position;

      setRules({
        banpickMode,
        peopleMode,
        timeUnlimited,
        nowSet,
        audienceCount,
        position: positionValue,
        //role ÏÑ§Ï†ï
        role: !searchParams!.get('position')
          ? 'host'
          : (searchParams!.get('position') as 'blue' | 'red' | 'audience') === 'audience'
            ? 'audience'
            : 'guest',
      });
      const connectWebSocket = async () => {
        if (searchParams!.get('roomId')) setRoomId(searchParams!.get('roomId') as string);
        // WebSocket ÏÑúÎ≤Ñ URL Í∞ÄÏ†∏Ïò§Í∏∞
        const response = await fetch('/api/socket/io');
        const { wsUrl } = await response.json();

        if (!response.ok) throw new Error('WebSocket server not ready');

        // WebSocket Ïó∞Í≤∞ ÌååÎùºÎØ∏ÌÑ∞
        const params = new URLSearchParams({
          roomId: searchParams!.get('roomId') ? searchParams!.get('roomId') : roomId,
          userId: userId,
          position: searchParams!.get('position') ? searchParams!.get('position') : position,
          host: String(searchParams!.get('position') ? false : true),
        });

        const _ws = new WebSocket(`${wsUrl}?${params.toString()}`);
        setWs(_ws);

        _ws.onopen = () => {
          console.log(
            '‚úÖ WebSocket connected' +
              `userId${userId}roomId` +
              `${searchParams!.get('roomId') ? searchParams!.get('roomId') : roomId}`,
          );
          if (!searchParams!.get('position')) {
            //hostÏùºÎïå (sharePop.tsxÏóêÏÑú Î©îÏù∏ ÌéòÏù¥ÏßÄÏóêÏÑú Í∞ÄÏû• Î®ºÏ†Ä ÏÑ∏ÌåÖÎê®)
            console.log(hostInfo, 'hostInfo');
            if (pathName === '/') {
              //Ï¥àÍ∏∞ ÌôîÎ©¥ ÏÜåÏºì Ïã§Ìñâ
              _ws?.send(
                JSON.stringify({
                  type: 'init',
                  userId: localStorage.getItem('lol_ban_host_id') as string,
                  roomId: `${searchParams!.get('roomId') ? searchParams!.get('roomId') : roomId}`,
                  banpickMode,
                  peopleMode,
                  timeUnlimited,
                  nowSet,
                  hostInfo,
                  host: true,
                  role: 'host',
                  position: `${searchParams!.get('position') ? searchParams!.get('position') : position}`,
                }),
              );
            }
          } else {
            //Ïù¥ÌõÑÏóê Ï†ëÏÜçÎêú guestÎÇò Í¥ÄÏ§ë

            _ws?.send(
              JSON.stringify({
                type: 'init',
                userId: userId,
                roomId: `${searchParams!.get('roomId') ? searchParams!.get('roomId') : roomId}`,
                host: false,
                position: `${searchParams!.get('position') ? searchParams!.get('position') : position}`,
                role:
                  (searchParams!.get('position') as 'blue' | 'red' | 'audience') === 'audience' ? 'audience' : 'guest',
              }),
            );

            _ws?.send(
              JSON.stringify({
                type: 'join',
                roomId: `${searchParams!.get('roomId') ? searchParams!.get('roomId') : roomId}`,
                userId,
                role:
                  (searchParams!.get('position') as 'blue' | 'red' | 'audience') === 'audience' ? 'audience' : 'guest',
              }),
            );
          }
        };
        _ws.onmessage = (event) => {
          const data = JSON.parse(event.data);

          // Î©îÏãúÏßÄ ÌÉÄÏûÖÏóê Îî∞Îùº ÏïåÎ¶ºÏùÑ ÎùÑÏõÄ
          // ÌéòÏù¥ÏßÄ Î≥ÑÎ°ú Ïù¥Î≤§Ìä∏ Ï∂îÍ∞Ä ÌïÑÏöî

          if (data.type === 'init') {
            console.log(`üì© ÏÉà Î©îÏãúÏßÄ: ${JSON.stringify(data)}`);
          }
          if (data.type === 'ready') {
            console.log(`üì© ÏÉà Î©îÏãúÏßÄ: ${JSON.stringify(data)}`);
            setHostRules(data.hostInfo);
            setGuestRules(data.guestInfo);
          }
          if (data.type === 'banpickStart') {
            console.log(`üì© ÏÉà Î©îÏãúÏßÄ: ${JSON.stringify(data)}`);
            router.push('/banpickTeam');
          }
          if (data.type === 'on') {
            console.log(`üì© ÏÉà Î©îÏãúÏßÄ: ${JSON.stringify(data)}`);
          }
          if (data.type === 'join') {
            console.log(`üì© ÏÉà Î©îÏãúÏßÄ: ${JSON.stringify(data)}`);
            setRules(data);
            setHostRules(data.hostInfo);
            setGuestRules(data.guestInfo);
          }

          if (data.type === 'closeByHost') {
            console.log(`üì© ÏÉà Î©îÏãúÏßÄ: Ï¢ÖÎ£å`);
            setIsOpen(true);
            setContent('Í≤åÏûÑ Ï£ºÏµúÏûêÍ∞Ä Í≤åÏûÑÏùÑ Ï¢ÖÎ£åÌñàÏäµÎãàÎã§.');
            setBtnList([
              {
                text: 'ÎèåÏïÑÍ∞ÄÍ∏∞',
                func: () => {
                  setIsOpen(false);
                  router.push('/');
                },
              },
            ]);
          }
          if (data.type === 'closeByGuest') {
            console.log(data, 'closeByGuest');
            setRules(data);
            setHostRules(data.hostInfo);
            setGuestRules(data.guestInfo);
          }
          if (data.type === 'closeByAudience') {
            console.log(`üì© closeByAudience`, data);
            setRules({
              banpickMode,
              peopleMode,
              timeUnlimited,
              role,
              position,
              audienceCount: data.audienceCount,
              nowSet,
            });
          }
          if (data.type === 'overCount') {
            setIsOpen(true);
            setContent('Ï†ïÏõêÏù¥ Ï¥àÍ≥º ÎêòÏóàÏäµÎãàÎã§');
            setBtnList([
              {
                text: 'ÎèåÏïÑÍ∞ÄÍ∏∞',
                func: () => {
                  setIsOpen(false);
                  router.push('/');
                },
              },
            ]);
          }
          if (data.type === 'noRoom') {
            console.log(`üì© ÏÉà Î©îÏãúÏßÄ: noRoom`);
            setIsOpen(true);
            setContent('Í≥µÏú†Îêú Í≤åÏûÑÏù¥ ÏóÜÏäµÎãàÎã§.');
            setBtnList([
              {
                text: 'ÎèåÏïÑÍ∞ÄÍ∏∞',
                func: () => {
                  setIsOpen(false);
                  router.push('/');
                },
              },
            ]);
          }
          if (data.type === 'image') {
            setCurrentSelectedPick(data.params.name, data.params.info);
          }
          if (data.type === 'champion') {
            const { banPickObject, currentLocation, selectedTeamIndex, selectedTeam, currentSelectedPick } =
              useBanStore.getState();
            const { banpickMode } = useRulesStore.getState();

            let index = banPickObject.find((value) => value.location === currentLocation)?.index as number;
            // ÌòÑÏû¨ Î∞¥ÌîΩ Ï†ïÎ≥¥Î•º Î∞îÍøîÏ§ÄÎã§.
            setBanPickObject(index, currentSelectedPick[0].name, currentSelectedPick[0].info, false);
            // Ï±îÌîºÏñ∏ Ï†ïÎ≥¥Î•º Î∞îÍøîÏ§ÄÎã§.
            setChangeChampionInfo(currentSelectedPick[0].name, selectedTeam[selectedTeamIndex].banpick);
            // ÌîºÏñ¥Î¶¨Ïä§ Ïùº Í≤ΩÏö∞
            if (banpickMode !== 'tournament') {
              if (selectedTeam[selectedTeamIndex].banpick === 'pick') {
                const selectedChampion = {
                  name: currentSelectedPick[0].name,
                  info: currentSelectedPick[0].info,
                  line: lineMapping[selectedTeam[selectedTeamIndex].line] ?? -1,
                };
                if (selectedTeam[selectedTeamIndex].color === 'blue') {
                  setBlueBan(selectedChampion);
                } else {
                  setRedBan(selectedChampion);
                }
              }
            }

            index += 1;

            // Î∞¥ÌîΩ ÏúÑÏπòÎ•º Îã§ÏùåÏúºÎ°ú Î≥ÄÍ≤ΩÌï¥Ï§ÄÎã§. Í∑∏Î¶¨Í≥† ÌòÑÏû¨ÏÑ†ÌÉùÏù¥ÎØ∏ÏßÄ Ï¥àÍ∏∞Ìôî
            setCurrentLocation(index);
            setCurrentSelectedPick('', InfoData);
            setSelectedTeamIndex();
          }
          if (data.type === 'random') {
            const { banPickObject, currentLocation, selectedTeamIndex, selectedTeam } = useBanStore.getState();
            let index = banPickObject.find((value) => value.location === currentLocation)?.index as number;

            if (selectedTeam[selectedTeamIndex].banpick === 'ban') {
              setBanPickObject(index, data.data.randomName, data.data.randomInfo, true); // ÎûúÎç§ Ï±îÌîºÏñ∏ÏùÑ ÏÑ†ÌÉùÌï¥Ï§ÄÎã§
            } else {
              setBanPickObject(index, data.data.randomName, data.data.randomInfo, true); // ÎûúÎç§ Ï±îÌîºÏñ∏ÏùÑ ÏÑ†ÌÉùÌï¥Ï§ÄÎã§
              setChangeChampionInfo(data.data.randomName, selectedTeam[selectedTeamIndex].banpick); // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ï±îÌîºÏñ∏Ïùò status Î≥ÄÍ≤Ω
            }

            index += 1;
            setCurrentLocation(index); // Îã§Ïùå ÏúÑÏπòÎ•º Ï†ÄÏû•ÌïúÎã§
            setCurrentSelectedPick('', InfoData); // Ï¥àÍ∏∞Ìôî
            setSelectedTeamIndex(); // Ìó§Îçî Î≥ÄÍ≤ΩÏùÑ ÏúÑÌïú IndexÍ∞í ÏàòÏ†ï
          }
          if (data.type === 'Peerless') {
            const { blueBan, redBan } = usePeerlessStore.getState();
            setTeamBan(blueBan, redBan);
            setRedBanClear();
            setBlueBanClear();
          }
          if (data.type === 'clearPeerless') {
            setPeerlessSet();
            setClearBanPickObject();
            setClearSelectTeamIndex();
            setClearCurrentLocation();
            router.refresh();
          }
        };

        _ws.onerror = (error) => console.error('‚ùå WebSocket error:', error);
        _ws.onclose = () => console.log('‚ùå WebSocket disconnected');

        socketRef.current = _ws;
      };

      connectWebSocket();
    }
    return () => {
      if (ws) {
        console.log(ws);
        ws!.close();
      }
    };
  };
  return { setSocket };
}

export default useBanpickSocket;
